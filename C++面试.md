# 精通C++之面试题总结

## Contents

[1. 数据类型](#1数据类型)

[2. 面向对象](#面向对象)

[3. 内存模型](#内存模型)

[4. STL模板库](#STL模板库)

[5. 数据结构](#数据结构)

[6. 多线程](#多线程)

[7. 设计模式](#设计模式)

[8. 网络协议](#网络协议)

[9. 操作系统](#操作系统)

## 数据类型

### const

1. const和#define相比的优点？

   - 可以指定数据类型
   - 可以使用C++的作用域规则
   - 可以用于更复杂的类型如数组和结构

2. const 指针？

   - 指向const的指针

     ```c++
     int const *p;
     const int *p;
     ```

     p的内容不能改变，但p可以指向别的内容
     
   - const修饰指针
   
     ```c++
     int *const p;
     ```
   
     p不能指向别的内容，但可以修改指向的内容
   
3. const修饰函数传入参数？

   函数将不能修改该参数或该参数所指向的对象

4. const修饰函数返回值？

   用户不能修改返回值，返回值必须赋给常变量或常指针。

5. const修饰成员函数？

   ```C++
   void func() const{};
   ```

   - const对象只能访问const成员函数，非const对象可以访问任意成员函数
   - const对象的成员不能修改
   - const成员函数不能修改对象的数据

6. const可以不初始化吗？

   const对象初始化后无法改变，因此必须初始化

7. const作用域？

   const对象通常只在本文件内有效，如希望其在其他文件也有效，需要加extern关键字。即在一个文件中定义const，在其他多个文件中声明并使用。


### Static 静态类型

1. static的作用？
   1. 修饰普通变量
   
   2. 修饰普通函数
   
3. 修饰成员变量
   
   4. 修饰成员函数
   
      只能调用类的静态成员变量和静态成员函数
   
2. static变量存储在哪里？

   静态变量区

3. static变量的生命周期？

   整个程序

4. static变量的作用域

   当前文件

5. static变量的初始化

   默认初始化为0，存放于静态变量区的BSS段（非初始化数据段）

6. 类static变量能初始化吗

   不可以，因为类的static变量和函数是类内所有对象共享的，在对象实例化之前便存在在静态区，不可以在对象实例化的时候对其初始化，需要在类外进行初始化。

7. static变量与全局变量的区别

   全局变量的作用域为整个程序，而static作用域为当前文件，因此static有隐藏的作用。二者的生存周期都是整个程序，都存放于静态变量存储区。

### 函数指针

1. 定义

   ```c++
   int func(int a){return a;}
       
   int (*pf)(int) = func;
   cout << pf(10);
   
   typedef int (*PF)(int);
   PF pf1 = func;
   cout << pf1(10);
   ```

2. 指针辨析

   ```c++
   int p[]; //int数组
   int *p[]; //int指针的数组
   int (*p)[];//指向int数组的指针
   int *p(); //返回int指针的函数
   int (*p)(); //函数指针
   int (*p[])(); //存放函数指针的数组
   ```

### lambda表达式

### inline函数

1. 编译器怎么处理inline
2. inline可以修饰虚函数吗

### union联合

### numerate类型

### explicit显式类型

[back to top](#contents)

## 面向对象

### 封装

1. 封装的作用

### 继承

1. 访问权限
2. 继承方式

### 多态

1. 静态多态
   1. 函数重载
   2. 泛型编程：模板函数、模板类
2. 动态多态
3. 静态多态与动态多态的优缺点
4. 静态多态与动态多态的实现时间

### 虚函数

1. 虚函数的作用

2. 析构函数为虚函数，基类与子类的构造与析构顺序

   内存泄漏问题

### 虚继承

### 模板类、模板函数

#### 可变参数模板

### 友元类与友元函数

### 强制类型转换

1. 静态 static_cast

   ```c++
   static_cast<type-id> (expression);
   ```

   编译时期的静态类型检测，强制转换，没有类型检查，不安全

   用于：

   - 基类和子类之间的转换，子类指针转父类指针安全（上行），父类指针转子类不安全（下行）。不能进行无关类型指针之间的转换。
   - 基本数据类型转换。
   - 空指针转换为目标类型的空指针
   - 任何类型的表达式转换为void类型
   - 不能去掉类型的const、volitale属性

   主要执行非多态的转换操作，建议替换所有隐式转换

2. 动态 dynamic_cast

   ```c++
   dynamic_cast<type-id> (expression)
   ```

   运行时的动态类型检测，转换失败返回NULL；不支持基础类型转换

   用于：

   - 安全的向下转换（父类转为子类）（也可以向上转换，但没必要，因为可以用虚函数实现）
   - 父类中必须有虚函数保证多态，才能使用动态转换，否则转换失败。
   - 多重继承情况下，用于派生类的多个基类之间的相互转换

3. const_cast

   主要用于解除常指针和常引用的const和volatile属性

4. reinterpret_cast

   一般不建议使用。用于将指针转换为其他类型指针，也允许将指针转化为整数类型。可以在非相关的类型之间进行，在确保安全的情况下可以适当使用。

5. 什么是强制类型转换？

   相当于一次函数调用，结果是生成了一个新的数据实体，或者生成一个指向原数据实体但解释方式发生变化的指针（或引用）

6. 强制类型转换的安全性？

   使用静态类型转换时的安全需要由程序员保证，使用动态类型转换时编译器会动态检查转换的安全性。

7. 动态类型转换的安全性？

   动态类型转换只能用于有继承关系的类之间的类型转换，当进行安全的向上转换时（子类转父类），与静态转换相同；当进行乡下转换时，运行时动态检查，依赖于对象的RTTI（Run-Time Type Information）通过虚函数表找到RTTI确定基类指针所指对象的真实类型来确定是否能进行转换。

8. const_cast能将变量转换为非const吗？

   只能用于去除指针或引用的const或volatile属性，变量本身的属性不能被去除。

### 运行时类型信息（RTTI）

## 内存模型

### 内存空间

1. 有哪些内存空间

### 指针与引用

1. 指针与引用的区别？
2. 引用可以为空吗？指针可以为空吗？初始化？
3. sizeof()?
4. 参数传递过程的区别？

### 深拷贝与浅拷贝

### new，delete与malloc，free

### RAII

### 内存碎片管理

### 动态链接与静态链接

### 头文件

1. 如何避免头文件被多次包含？
2. include头文件时编译器的操作？

## STL模板库

### 智能指针

1. 循环引用问题

### vector

### list

### map

### set

### Initializer_list

## 数据结构

### 排序算法

### 哈希表

### 二叉搜索树

#### 红黑树

#### B树，B+树

#### 线索二叉树

### 图算法

#### dijkstra算法

#### floyd算法

## 多线程

### 进程与线程

### 锁机制

## 设计模式

### 设计原则

### 单例模式

### 观察者模式

### 工厂模式

#### 外观模式

#### 适配器模式

## 网络协议

### OSI七层模型

### TCP五层模型

### TCP与UDP

#### 拥塞控制

#### 粘包

### 三次握手、四次挥手

## 游戏开发

https://blog.csdn.net/u012999985/article/details/79118198